//let hook = import! "scripts/hook.glu"
let array = import! "std/array.glu"
let int = import! "std/int.glu"
let list = import! "std/list.glu"
let { List } = list
let falcon = import! "scripts/falcon.glu"
let finch = import! "scripts/finch.glu"
let string = import! std.string
let utility = import! "scripts/utility.glu"
let { ok_err, show_int, some_err } = utility

let show_int = int.show.show


// helper functions
let list_append l m =
  match l with
  | Cons x xs -> Cons x (list_append xs m)
  | Nil -> m


// This is the address used as the base for making symbolic variables
let base_symbolic_memory_address = 0xff000000

type SymbolicString = {
  name: String,
  address: Int
}

/// A wrapped ExecutorDriver which tracks extra information
type SymDriver = {
    // The driver we are wrapping
    driver: ExecutorDriver,
    // The address where we will create our next symbolic value in memory
    next_symbolic_address: Int,
    // A list of all symbolic variables
    symbolic_scalars: List IlScalar,
    // A list of symbolic strings we've introduced this driver
    symbolic_strings: List SymbolicString
}


//
// BEGIN HOOK REDEFINITIONS
//
// We redefine some things from the hook library
// TODO remove this once we know how to resolve circular dependencies in gluon
type Hook = {
    name: String,
    hook: SymDriver -> Option (List SymDriver)
}

/// Run through all of the hooks. If a hook executes on this driver, return the
/// new driver. Otherwise, returns None
let run_hooks hooks driver
  : List Hook ->
    SymDriver ->
    Option (List SymDriver) =
  
  let f hooks driver =
    match hooks with
    | Cons hook hooks ->
      match hook.hook driver with
      | Some driver -> Some driver
      | None -> f hooks driver
    | Nil -> None
  
  let d = f hooks driver

  d
//
// END HOOK REDEFINITIONS
//


/// Load a symdriver from a file
let load_file filename start_address
  : String ->
    Option Int ->
    (LoaderElfLinker, SymDriver) =

  // Load the elf
  falcon.println "loading ElfLinker"
  let binary = falcon.loader.elf_linker.new filename True
  falcon.println "Loaded"

  let start_address =
    match start_address with
    | Some start_address -> start_address
    | None -> falcon.loader.elf_linker.program_entry binary

  // Get the architecture for this binary
  let architecture = falcon.loader.elf_linker.architecture binary

  // And the endianness of that architecture
  let endian = falcon.architecture.endian architecture

  // Get the program
  let program = falcon.il.program.new 1

  falcon.println "Created new program"

  let function = falcon.loader.elf_linker.function binary start_address

  falcon.println "Got a new function"

  let function = some_err function "Could not get function for start_address"

  falcon.println "Unwrapped function"

  let program = falcon.il.program.add_function program function

  falcon.println "Added function to program"

  // Get the program location corresponding to the start location
  let start_location =
    falcon.il.program_location.from_address program start_address
  let start_location =
    some_err start_location "Unable to get program location at start address"

  // Create a new symbolic memory
  let backing = falcon.loader.elf_linker.memory binary
  let symbolic_memory = finch.symbolic_memory.new_with_backing endian backing

  // Create a new symbolic state
  let start_state = finch.state.new symbolic_memory
  let start_state = finch.platform.mips_linux.initialize start_state binary

  let symdriver = {
    driver = finch.driver.new program start_location start_state architecture,
    next_symbolic_address = base_symbolic_memory_address,
    symbolic_scalars = Nil,
    symbolic_strings = Nil
  }

  (binary, symdriver)


/// Load a SymDriver from a file, following the mips standard load
let standard_load filename
  : String ->
    (LoaderElfLinker, SymDriver) =
  
  let driver = finch.platform.mips_linux.standard_load filename

  let symdriver = {
    driver = driver,
    next_symbolic_address = base_symbolic_memory_address,
    symbolic_scalars = Nil,
    symbolic_strings = Nil
  }

  ((falcon.loader.elf_linker.new filename False), symdriver)


/// Get the address of the instruction the driver is currently executing, if the
/// driver is currently executing an address
let address driver
  : SymDriver ->
    Option Int =
  
  finch.driver.address driver.driver


/// Get the driver's program
let program driver : SymDriver -> IlProgram =
  finch.driver.program driver.driver


/// Set the value of a scalar in this driver's state
let set_scalar driver name value
  : SymDriver ->
    String ->
    IlExpression ->
    SymDriver =
  
  {
    driver = finch.driver.set_scalar driver.driver name value,
    .. driver
  }


/// Set the driver's location to the given address.
let set_location_address driver address
  : SymDriver ->
    Int ->
    Option SymDriver =
  
  let program = finch.driver.program driver.driver
  let location = falcon.il.program_location.from_address program address
  match location with
  | Some location ->
    Some {
      driver = finch.driver.set_location driver.driver location,
      ..driver
    }
  | None -> None


/// Symbolically step the driver forward
let step driver
  : SymDriver ->
    List SymDriver =
  
  // step the driver
  let drivers = finch.driver.step driver.driver

  // Create a list of SymDrivers from the array of drivers
  let f drivers i =
    if (array.len drivers) == i then
      Nil
    else
      let d = array.index drivers i
      let d = {driver=d, ..driver}
      Cons d (f drivers (i + 1))
  
  f drivers 0


/// Drive to a specified address, and merge all drivers once hitting that
/// address. This bypasses hooks, and is built for speed
let drive_and_merge driver address max_steps
  : SymDriver ->
    Int ->
    Int ->
    Option SymDriver =
  
  match finch_prim.drive_and_merge driver.driver address max_steps with
  | Some d -> Some { driver = d, .. driver }
  | None -> None

/// Step the driver a given number of instructions forward, executing hooks as
/// necessary
///
/// driver = The SymDriver to step
/// address = The address to stop execution on
/// max_steps = The maximum number of steps to take
/// hooks = A list of hooks to execute over drivers
let drive_to_address driver address max_steps hooks
  : SymDriver ->
    Int -> 
    Int -> 
    List Hook ->
    List SymDriver =

  // sdta = step driver to address, the main loop of this function
  let sdta drivers address steps hooks final_drivers
    : List SymDriver ->
      Int -> 
      Int -> 
      List Hook -> 
      List SymDriver -> 
      List SymDriver =

    // Loop through drivers, performing a single step
    //
    // Returns drivers that need to be stepped further, and drivers which
    // have hit the target address
    let step_drivers drivers address hooks stepped_drivers final_drivers
      : List SymDriver -> 
        Int -> 
        List Hook -> 
        List SymDriver -> 
        List SymDriver -> 
        (List SymDriver, List SymDriver) =
      
      match drivers with
      | Cons driver remaining_drivers ->
        let program_location = finch.driver.location driver.driver
        let program = finch.driver.program driver.driver
        let instruction =
          falcon.il.program_location.instruction program_location program
        
        match instruction with
        | Some instruction ->
          let instruction_str = falcon.il.instruction.str instruction
          falcon.println (string.append "Instruction: " instruction_str)
        | None -> ()

        // If we have a hook for this driver, we execute that hook, otherwise
        // we will step the driver
        let this_stepped_drivers =
          match run_hooks hooks driver with
          | Some drivers -> drivers
          | None -> step driver

        // We need to sort all the resulting drivers into step_drivers or
        // final_drivers
        let sort_drivers drivers stepped_drivers final_drivers
          : List SymDriver ->
            List SymDriver ->
            List SymDriver ->
            (List SymDriver, List SymDriver) =

          match drivers with
          | Cons driver drivers ->
            match finch.driver.address driver.driver with
            | Some step_address ->
              if step_address == address then
                falcon.println "Found final driver"
                let s = falcon.hex step_address
                let s = string.append s " "
                let s = string.append s (falcon.hex address)
                falcon.println s
                sort_drivers drivers stepped_drivers (Cons driver final_drivers)
              else
                sort_drivers drivers (Cons driver stepped_drivers) final_drivers
            | None -> 
              sort_drivers drivers (Cons driver stepped_drivers) final_drivers
          | Nil -> (stepped_drivers, final_drivers)

        let (stepped_drivers, final_drivers) = sort_drivers this_stepped_drivers stepped_drivers final_drivers

        // Step the remaining drivers
        step_drivers remaining_drivers address hooks stepped_drivers final_drivers
        //(step_drivers, final_drivers)

      | Nil ->
        (stepped_drivers, final_drivers)
        
    let (stepped_drivers, final_drivers) =
      step_drivers drivers address hooks Nil final_drivers

    if steps == 0 then
      final_drivers
    else
      match stepped_drivers with
      | Nil ->
        final_drivers
      | Cons _ _ ->
        sdta stepped_drivers address (steps - 1) hooks final_drivers
  sdta (Cons driver Nil) address max_steps hooks Nil



/// Get an Int from a scalar
///
/// If the scalar does not have a constant value, or the scalar does not exist,
/// None will be returned.
let get_scalar_constant_value driver scalar_name
  : SymDriver ->
    String ->
    Option Int =

  let state = finch.driver.state driver.driver
  let scalar = finch.state.scalar state scalar_name
  match scalar with
  | Some expression ->
    let e = finch.state.symbolize_expression state expression
    match falcon.eval e with
    | Some constant -> falcon.il.constant.value_u64 constant
    | None -> None
  | None -> None


/// Get string from driver memory
let get_string driver address
  : SymDriver ->
    Int ->
    Option String =

  let f driver i =
    let state = finch.driver.state driver.driver
    let memory = finch.state.memory state
    let byte = finch.symbolic_memory.load memory (address + i) 8
    match byte with
    | Some byte ->
      match falcon.eval byte with
      | Some constant ->
        match falcon.il.constant.value_u64 constant with
        | Some value ->
          if value == 0 then
            Some ""
          else
            match f driver (i + 1) with
            | Some tail -> 
              match falcon.int_to_string value with
              | Some head -> Some (string.append head tail)
              | None -> None
            | None -> None
        | None -> None
      | None -> None
    | None -> None
  f driver 0


/// Create a buffer in memory where all values are symbolic
let make_symbolic_buffer driver name length
  : SymDriver ->
    String ->
    Int ->
    (SymDriver, Int) =
  
  let address = driver.next_symbolic_address
  
  let f driver i
    : ExecutorDriver ->
      Int ->
      (ExecutorDriver, List IlScalar) =

    if i == length then
      (driver, Nil)
    else
      let scalar_name = (string.append name (show_int i))
      let scalar = falcon.il.scalar.new name 8
      let variable = falcon.il.expression.scalar scalar
      let driver = finch.driver.store driver (address + i) variable
      let (driver, new_symbolic_scalars) = f driver (i + 1)
      (driver, Cons scalar new_symbolic_scalars)
  
  let (d, new_symbolic_scalars) = f driver.driver 0

  let symbolic_scalars =
    list_append driver.symbolic_scalars new_symbolic_scalars

  let sym_driver = {
    driver = d,
    next_symbolic_address = (driver.next_symbolic_address + length),
    symbolic_scalars = symbolic_scalars,
    symbolic_strings = driver.symbolic_strings
  }

  (sym_driver, address)


/// Steal some of our symbolic memory space to make a non-symbolic buffer
let make_buffer driver length
  : SymDriver ->
    Int ->
    (SymDriver, Int) =
  
  let address = driver.next_symbolic_address
  
  ({
    driver = driver.driver,
    next_symbolic_address = (driver.next_symbolic_address + length),
    .. driver
  }, address)


/// Create a null-terminated string where all values are symbolic
///
/// length includes the null-terminated character
let make_symbolic_string driver name length 
  : SymDriver ->
    String ->
    Int ->
    (SymDriver, Int) =

  // make the symbolic string
  let (driver, string_address) = make_symbolic_buffer driver name (length - 1)

  // null-terminate it
  let address = driver.next_symbolic_address
  let const0 = falcon.il.constant.new 0 8
  let const0 = falcon.il.expression.constant const0
  let d = finch.driver.store driver.driver address const0

  let symbolic_strings =
    Cons {name=name, address=address} driver.symbolic_strings

  let sym_driver = {
    driver = d,
    next_symbolic_address = driver.next_symbolic_address + 1,
    symbolic_scalars = driver.symbolic_scalars,
    symbolic_strings = symbolic_strings
  }

  (sym_driver, address)


/// If a symbolic string has already been created, get it's address
let get_symbolic_string driver name
  : SymDriver ->
    String ->
    Option Int =
  
  let f ss =
    match ss with
    | Cons ss xss ->
      if ss.name == name then
        Some ss.address
      else
        f xss
    | Nil -> None
  
  f driver.symbolic_strings


/// Load a value from the memory in this symdriver
let load driver address bits
  : SymDriver ->
    Int ->
    Int ->
    Option IlExpression =

  finch.driver.load driver.driver address bits


/// Store a value into the symdriver
let store driver address value
  : SymDriver ->
    Int ->
    IlExpression ->
    SymDriver =

    {
      driver = finch.driver.store driver.driver address value,
      .. driver
    }


/// Merge this SymDriver with another SymDriver, assuming they are at the same
/// location
let merge driver other_driver : SymDriver -> SymDriver -> Option SymDriver =

  match finch.driver.merge driver.driver other_driver.driver with
  | Some merged_driver ->

    // our next_symbolic_address will be whichever address is higher
    let next_symbolic_address =
      if driver.next_symbolic_address > other_driver.next_symbolic_address then
        driver.next_symbolic_address
      else
        other_driver.next_symbolic_address

    // make sure we have the complete set of symbolic_scalars
    let f symbolic_scalars other_scalars
      : List IlScalar ->
        List IlScalar ->
        List IlScalar =
      let g ss s : List IlScalar -> IlScalar -> Bool =
        match ss with
        | Cons xs xxs -> falcon.il.scalar.eq xs s
        | Nil -> False
      match other_scalars with
      | Cons os oss ->
        if g symbolic_scalars os then
          f symbolic_scalars oss
        else
          f (Cons os symbolic_scalars) oss
      | Nil -> symbolic_scalars
    let symbolic_scalars =
      f driver.symbolic_scalars other_driver.symbolic_scalars

    // TODO handle symbolic_strings
    Some {
      driver = merged_driver,
      next_symbolic_address = next_symbolic_address,
      symbolic_scalars = symbolic_scalars,
      .. driver
    }
  
  | None -> None


/// Merge a list of SymDriver
let merge_list drivers : List SymDriver -> Option SymDriver =
  match drivers with
  | Cons d dd ->
    match merge_list dd with
    | Some driver -> merge d driver
    | None -> Some d
  | Nil -> None


/// Get the length of a string. Handles symbolic strings.
let strlen driver address max_length
  : SymDriver ->
    Int ->
    Int ->
    Int =
  
  let null_byte = falcon.il.expression.constant (falcon.il.constant.new 0 8)
  
  let f driver i : SymDriver -> Int -> Int =
    if i == max_length then
      i
    else
      match load driver (address + i) 8 with
      | Some expression ->
        let test_expr = falcon.il.expression.cmpneq null_byte expression
        let state = finch.driver.state driver.driver
        match finch.state.symbolize_and_eval state test_expr with
        | Some _ -> f driver (i + 1)
        | None -> i
      | None -> i
  
  f driver 0


/// Add a path constraint to this driver
let add_path_constraint driver constraint
  : SymDriver ->
    IlExpression ->
    SymDriver =
  
  {
    driver = finch.driver.add_path_constraint driver.driver constraint,
    .. driver
  }


{
  SymDriver,

  add_path_constraint,
  address,
  drive_and_merge,
  drive_to_address,
  get_scalar_constant_value,
  get_symbolic_string,
  get_string,
  load,
  load_file,
  make_buffer,
  make_symbolic_buffer,
  make_symbolic_string,
  merge,
  merge_list,
  program,
  set_location_address,
  set_scalar,
  standard_load,
  step,
  store,
  strlen
}